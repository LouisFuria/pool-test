<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FURIA DEX · Base Sepolia</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
  :root{
    --bg:#0c0f16;--panel:#121725;--muted:#7f8aa3;--text:#e7ecf7;--primary:#8b5cf6;--primary-2:#a78bfa;--ok:#10b981;--err:#ef4444;--line:#1b2235;--soft:#141a2a;
  }
  *{box-sizing:border-box} html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  a{color:inherit;text-decoration:none}
  .wrap{max-width:1180px;margin:24px auto;padding:0 16px}
  .top{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .brand{font-weight:800;font-size:28px;letter-spacing:.5px}
  .crumb{color:var(--muted);font-size:14px}
  .right{margin-left:auto;display:flex;gap:10px;align-items:center}
  .chip{background:#0f1628;padding:8px 12px;border-radius:999px;color:#cbd5e1;border:1px solid var(--line);font-size:13px}
  .btn{background:var(--primary);color:#000;padding:10px 16px;border-radius:12px;border:none;cursor:pointer;font-weight:800}
  .btn.secondary{background:#1b2235;color:#e2e8f0}
  .btn.ghost{background:transparent;border:1px solid var(--line);color:#cbd5e1}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .tabs{display:flex;gap:10px;margin:16px 0}
  .tab{padding:10px 16px;border-radius:12px;background:var(--soft);cursor:pointer;color:#a5b0cf;border:1px solid var(--line)}
  .tab.active{color:#fff;background:var(--panel);box-shadow:0 0 0 1px #1f2840 inset}
  .grid{display:grid;gap:16px}
  @media (min-width:980px){.grid-2{grid-template-columns:1.15fr .85fr}}
  .card{background:linear-gradient(180deg,#ffffff08,transparent),var(--panel);border:1px solid var(--line);border-radius:16px;padding:18px}
  .h{font-size:13px;letter-spacing:.12em;color:#9fb0d6;text-transform:uppercase;margin-bottom:12px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .input, select{width:100%;padding:14px 14px;border-radius:12px;background:#0f1422;color:#e5edff;border:1px solid var(--line);font-size:16px;outline:none}
  select{appearance:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 20 20" fill="%23a6b2d6"><path d="M5.5 7.5l4.5 5 4.5-5"/></svg>');background-repeat:no-repeat;background-position:right 10px center;padding-right:36px}
  .pill{padding:8px 12px;border-radius:999px;background:#0f1422;border:1px solid var(--line);color:#c9d5f2;cursor:pointer}
  .stat{background:#0e1320;border:1px solid var(--line);border-radius:16px;padding:16px;font-weight:700;display:flex;justify-content:space-between;align-items:center}
  .muted{color:var(--muted)} .big{font-size:28px}
  .swap-ctrls{display:grid;grid-template-columns:1fr 58px 1fr;gap:10px}
  .table{width:100%;border-collapse:collapse}
  .table th,.table td{padding:14px;border-bottom:1px solid var(--line);text-align:left}
  .note{color:#a7b3d5;font-size:13px;margin-top:8px}
  .toast{position:fixed;right:16px;bottom:16px;background:#0f1422;border:1px solid var(--line);color:#e8eeff;padding:12px 14px;border-radius:12px;box-shadow:0 4px 28px rgba(0,0,0,.35);display:none}
  dialog{border:none;border-radius:16px;padding:0;max-width:560px;width:92%;background:var(--panel);color:var(--text)}
  dialog .body{padding:18px}
  dialog::backdrop{background:rgba(0,0,0,.65)}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .green{color:var(--ok)} .red{color:var(--err)}
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <div class="brand">FURIA DEX</div>
    <div class="crumb">· Base Sepolia</div>
    <div class="right">
      <div id="netChip" class="chip">Réseau: —</div>
      <div id="addrChip" class="chip" style="display:none;cursor:copy" title="Cliquer pour copier">—</div>
      <button id="btnImportUSDC" class="btn ghost">+ USDC</button>
      <button id="btnDisconnect" class="btn secondary" style="display:none">Disconnect</button>
      <button id="btnConnect" class="btn">Connect</button>
    </div>
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="swap">Swap</div>
    <div class="tab" data-tab="pools">Pools</div>
    <div class="tab" data-tab="vaults">Vaults</div>
    <div class="tab" data-tab="leaderboard">Leaderboard</div>
    <div class="tab" data-tab="settings">Settings</div>
  </div>

  <!-- SWAP -->
  <section id="swap" class="grid grid-2">
    <div class="card">
      <div class="h">Swap ETH  USDC · Règle points: <b>10 pts / $ swappé</b></div>
      <div class="swap-ctrls">
        <select id="swapFrom"><option value="ETH">ETH</option><option value="USDC">USDC</option></select>
        <div style="display:flex;align-items:center;justify-content:center"><button id="btnFlip" class="pill" title="Inverser">⇄</button></div>
        <select id="swapTo"><option value="USDC">USDC</option><option value="ETH">ETH</option></select>
      </div>
      <div class="two" style="margin-top:10px">
        <input id="swapAmount" class="input" placeholder="Montant" inputmode="decimal"/>
        <input id="slippage" class="input" placeholder="Slippage % (affichage)" value="0.5"/>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="pill pct" data-p="25">25%</button>
        <button class="pill pct" data-p="50">50%</button>
        <button class="pill pct" data-p="75">75%</button>
        <button class="pill pct" data-p="100">100%</button>
      </div>
      <div class="card" style="margin-top:12px;background:#0f1422">
        <div class="muted">You Receive</div>
        <div id="youReceive" class="big">—</div>
        <div id="minOutBox" class="note">Min. reçu (slippage): —</div>
        <div id="gasBox" class="note">Estimation gas: —</div>
        <div id="impactBox" class="note">Impact prix: 0% (prix fixe)</div>
      </div>
      <div class="row" style="margin-top:12px;justify-content:space-between">
        <div>
          <div id="balances" class="muted">Solde: —</div>
          <div id="allowBox" class="note">Allowance USDC → Swap: —</div>
        </div>
        <div class="row">
          <button id="btnApproveMax" class="btn ghost">Approve Max</button>
          <button id="btnSwap" class="btn">Swap</button>
        </div>
      </div>
    </div>

<div class="card">
  <div class="h">Infos (Swap)</div>
  <div class="stat"><span>Prix ETH/USD</span><span id="priceBox" class="big">$—</span></div>
  <div class="stat" style="margin-top:10px"><span>Frais</span><span id="feeBox" class="big">—</span></div>
  <div class="stat" style="margin-top:10px"><span>TVL (équiv. ETH)</span><span id="tvlSwap" class="big">—</span></div>
  <div class="note">App appuie sur <b>Enter</b> pour lancer le swap.</div>
</div>  </section>

  <!-- POOLS -->
  <section id="pools" style="display:none">
    <div class="grid" style="grid-template-columns:repeat(4,1fr)">
      <div class="stat"><span>TVL (équiv. ETH)</span><span id="tvlPools" class="big">—</span></div>
      <div class="stat"><span>Volume ~24h</span><span id="volPools" class="big">$0</span></div>
      <div class="stat"><span>Mes points (swap)</span><span id="mySwapPts" class="big">0</span></div>
      <div class="stat"><span>Mes points (vault)</span><span id="myVaultPts" class="big">0</span></div>
    </div>
    <div class="card" style="margin-top:14px">
      <div class="h">Pools (points: <b>1 pt / $ / min</b>)</div>
      <table class="table">
        <thead><tr>
          <th>Pair</th><th>APY</th><th>TVL (ETH)</th><th>Vol(~24h)</th><th>Points règle</th><th></th>
        </tr></thead>
        <tbody id="poolRows"></tbody>
      </table>
      <div class="note"> Le dépôt “Pools” utilise le <b>même</b> contrat que le Vault. Ici, l’ADD réalise automatiquement un dépôt <b>50/50</b> (en $) dans le vault.</div>
    </div>
  </section>

  <!-- VAULTS -->
  <section id="vaults" style="display:none">
    <div class="grid" style="grid-template-columns:1fr 1fr;gap:16px">
      <div class="card">
        <div class="h">Vault ETH</div>
        <div class="big" id="vaultEthApy">25%</div>
        <div class="note">Règle points: <b>1 pt / $ / min</b> · refresh 10s</div>
        <div class="two" style="margin-top:10px">
          <input id="vaultEthAmount" class="input" placeholder="Montant ETH (ex: 0.1)"/>
          <div class="row"><button id="btnVaultMaxETH" class="pill">Max</button><button id="btnVaultDepositETH" class="btn">Déposer</button></div>
        </div>
        <div class="two" style="margin-top:10px">
          <input id="vaultEthWithdraw" class="input" placeholder="Retrait ETH (ex: 0.05)"/>
          <div class="row"><button id="btnVaultWithdrawETH" class="btn secondary">Retirer</button></div>
        </div>
      </div>
      <div class="card">
        <div class="h">Vault USDC</div>
        <div class="big" id="vaultUsdcApy">25%</div>
        <div class="note">Règle points: <b>1 pt / $ / min</b> · refresh 10s</div>
        <div class="two" style="margin-top:10px">
          <input id="vaultUsdcAmount" class="input" placeholder="Montant USDC (ex: 200)"/>
          <div class="row"><button id="btnVaultMaxUSDC" class="pill">Max</button><button id="btnVaultDepositUSDC" class="btn">Déposer</button></div>
        </div>
        <div class="two" style="margin-top:10px">
          <input id="vaultUsdcWithdraw" class="input" placeholder="Retrait USDC (ex: 100)"/>
          <div class="row"><button id="btnVaultWithdrawUSDC" class="btn secondary">Retirer</button></div>
        </div>
      </div>
    </div>
  </section>

  <!-- LEADERBOARD -->
  <section id="leaderboard" style="display:none">
    <div class="card">
      <div class="h">Leaderboard (vault points)</div>
      <table class="table">
        <thead><tr><th>#</th><th>Adresse</th><th>Points</th></tr></thead>
        <tbody id="lbRows"></tbody>
      </table>
      <div class="row" style="justify-content:flex-end;gap:8px;margin-top:10px">
        <button id="btnExportCSV" class="btn ghost">Exporter CSV</button>
        <button id="btnRefreshLB" class="btn secondary">Refresh</button>
      </div>
      <div class="note">Règle: <b>1 pt / $ / min</b> (lecture on-chain via <code>pointsOf</code> & <code>pendingPointsScaled</code>, refresh 10s).</div>
    </div>
  </section>

  <!-- SETTINGS -->
  <section id="settings" style="display:none">
    <div class="card">
      <div class="h">Paramètres</div>
      <div class="two">
        <div>
          <label class="muted">Slippage par défaut (%)</label>
          <input id="cfgSlippage" class="input" placeholder="0.5" />
        </div>
        <div>
          <label class="muted">Approve Max montant USDC</label>
          <input id="cfgApproveMax" class="input" placeholder="1000000000000" />
        </div>
      </div>
      <div class="row" style="margin-top:10px;justify-content:flex-end">
        <button id="btnSaveCfg" class="btn">Sauver</button>
      </div>
      <div class="note">Ces paramètres sont stockés localement.</div>
    </div>
  </section>
</div>

<!-- MODALS -->
<dialog id="dlgAdd">
  <div class="body">
    <div class="h">Déposer dans la pool</div>
    <div class="note" style="margin-bottom:8px">Entrer un <b>montant total en $</b>. Le dépôt sera réalisé 50% en ETH et 50% en USDC au prix courant.</div>
    <div class="two" style="margin-bottom:10px">
      <input id="addUsd" class="input" placeholder="Montant en $ (ex: 100)"/>
      <button id="btnAddConfirm" class="btn">Déposer</button>
    </div>
    <div class="two">
      <input id="addEthPreview" class="input" placeholder="≈ ETH" readonly />
      <input id="addUsdcPreview" class="input" placeholder="≈ USDC" readonly />
    </div>
    <div class="row" style="margin-top:10px;justify-content:flex-end">
      <button id="btnAddCancel" class="btn secondary">Annuler</button>
    </div>
  </div>
</dialog>

<dialog id="dlgRemove">
  <div class="body">
    <div class="h">Retirer de la pool</div>
    <div class="note" style="margin-bottom:8px">Entrer un <b>montant total en $</b> à retirer. Le retrait sera réalisé 50% en ETH et 50% en USDC au prix courant.</div>
    <div class="two" style="margin-bottom:10px">
      <input id="rmUsd" class="input" placeholder="Montant en $ (ex: 100)"/>
      <button id="btnRemoveConfirm" class="btn">Retirer</button>
    </div>
    <div class="two">
      <input id="rmEthPreview" class="input" placeholder="≈ ETH" readonly />
      <input id="rmUsdcPreview" class="input" placeholder="≈ USDC" readonly />
    </div>
    <div class="row" style="margin-top:10px;justify-content:flex-end">
      <button id="btnRemoveCancel" class="btn secondary">Annuler</button>
    </div>
  </div>
</dialog>

<div id="toast" class="toast"></div>

<script>
/* Surface les erreurs dans un toast pour éviter que l'UI “meure” silencieusement */
window.addEventListener('error', (e)=>{
  const t=document.querySelector('#toast');
  if(!t) return;
  const msg=(e && (e.error && e.error.message || e.message)) || 'Erreur script';
  t.textContent=msg; t.style.display='block'; clearTimeout(window.__tt); window.__tt=setTimeout(()=>t.style.display='none',2800);
});

(async function(){
  /* ========= CONFIG ========= */
  const CHAIN_ID_DEC = 84532;             // Base Sepolia
  const CHAIN_ID_HEX = '0x14A54';
  const SWAP_ADDRESS  = '0x9965B8ef813E6247c6788AF7836756a579474484'; // FixedPriceSwap (points swap via events)
  const VAULT_ADDRESS = '0x1720e9ef567d1f29076EcE7E47CBc5F12F52F335'; // Vault with Points (pendingPointsScaled)
  const USDC_ADDRESS  = '0x3F532813FEB32E1990d9c7Ca8Cb29b62C573512B'; // USDCMock
  const APY_POOL = 20;   // affichage
  const APY_VAULT = 25;  // affichage

  /* ========= ABIs ========= */
  const ERC20_ABI = [
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner,address spender) view returns (uint256)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
  const SWAP_ABI = [
    "function ethUsd() view returns (uint256)",   // 8 déc
    "function feeBps() view returns (uint256)",   // ex: 30
    "function USDC() view returns (address)",
    "function swapETHforUSDC() payable",
    "function swapUSDCforETH(uint256 usdcIn)",
    "event SwapETHforUSDC(address indexed user, uint256 ethIn, uint256 usdcOut, uint256 price8, uint256 feeBps)",
    "event SwapUSDCforETH(address indexed user, uint256 usdcIn, uint256 ethOut, uint256 price8, uint256 feeBps)"
  ];
  // Vault avec points “comme ton code qui marche”
  const VAULT_ABI = [
    "function depositETH() payable",
    "function depositUSDC(uint256 amount)",
    "function withdrawETH(uint256 amount)",
    "function withdrawUSDC(uint256 amount)",
    "function totalETH() view returns (uint256)",
    "function totalUSDC() view returns (uint256)",
    "function userETH(address) view returns (uint256)",
    "function userUSDC(address) view returns (uint256)",
    "function pointsOf(address) view returns (uint256 points, uint8 decimals_)",        // -> (uint,uint8)
    "function pendingPointsScaled(address) view returns (uint256)",                      // live points (1e6)
    "function claimPoints()",                                                            // optionnel
    "function ethUsd() view returns (uint256)"                                           // 8 déc
  ];

  /* ========= State ========= */
  let provider, signer, me, price8=0, feeBps=0, usdcDecimals=6;
  let swap, vault, usdc;

  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  function toast(txt){ const t=$("#toast"); t.textContent=txt; t.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>t.style.display='none',2600); }
  const fmt = (n,d=6)=> Number(n).toLocaleString(undefined,{maximumFractionDigits:d});
  const fmtUsd = (n)=> '$'+Number(n).toLocaleString(undefined,{maximumFractionDigits:2});
  const labelChain = id => id===8453?'Base':(id===84532?'Base Sepolia':`chain ${id}`);
  const save=(k,v)=>localStorage.setItem(k,JSON.stringify(v));
  const load=(k,d)=>{ try{ const v=JSON.parse(localStorage.getItem(k)); return (v==null?d:v); }catch{return d} };

  const price = ()=> price8/1e8;
  const applyFee = x => x * (1 - feeBps/10000);
  const usdToEth = usd => (price()? usd/price():0);
  const ethToUsd = eth => eth * price();

  /* ========= Wallet ========= */
  async function ensureProvider(){
    if(!window.ethereum){ toast('Installe MetaMask.'); throw new Error('no wallet'); }
    provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
    const net = await provider.getNetwork();
    $("#netChip").textContent = `Réseau: ${labelChain(net.chainId)}`;
  }
  async function connect(){
    try{
      await ensureProvider();
      const accs = await window.ethereum.request({ method:'eth_requestAccounts' });
      me = accs[0]; signer = provider.getSigner();
      let net = await provider.getNetwork();
      if(net.chainId!==CHAIN_ID_DEC){
        try{
          await window.ethereum.request({ method:'wallet_switchEthereumChain', params:[{ chainId: CHAIN_ID_HEX }] });
        }catch(e){
          if(e && (e.code===4902 || /not added|unrecognized/i.test(e.message||''))){
            await window.ethereum.request({
              method:'wallet_addEthereumChain',
              params:[{ chainId: CHAIN_ID_HEX, chainName:'Base Sepolia',
                nativeCurrency:{ name:'ETH', symbol:'ETH', decimals:18 },
                rpcUrls:['https://sepolia.base.org'],
                blockExplorerUrls:['https://base-sepolia.blockscout.com'] }]
            });
          } else { throw e; }
        }
        net = await provider.getNetwork();
      }
      $("#netChip").textContent=`Réseau: ${labelChain(net.chainId)}`;
      afterConnectUI();
      save('furia_connected',true);
      await onReady();
    }catch(err){ console.error(err); toast(err && err.message || 'Connexion impossible'); }
  }
  function afterConnectUI(){
    if(!me) return;
    $("#btnConnect").style.display='none';
    $("#btnDisconnect").style.display='inline-block';
    $("#addrChip").style.display='inline-block';
    $("#addrChip").textContent = me.slice(0,6)+'…'+me.slice(-4);
    $("#addrChip").onclick = async()=>{ try{ await navigator.clipboard.writeText(me); toast('Adresse copiée'); }catch{} };
  }
  function disconnect(){
    me=undefined; signer=undefined; save('furia_connected',false);
    $("#btnConnect").style.display='inline-block';
    $("#btnDisconnect").style.display='none';
    $("#addrChip").style.display='none';
  }
  $("#btnConnect").onclick = connect;
  $("#btnDisconnect").onclick = disconnect;

  $("#btnImportUSDC").onclick = async ()=>{
    if(!window.ethereum || !window.ethereum.request){ toast('Wallet non disponible'); return; }
    try{
      await window.ethereum.request({
        method:'wallet_watchAsset',
        params:{ type:'ERC20', options:{ address:USDC_ADDRESS, symbol:'USDC', decimals: usdcDecimals } }
      });
    }catch(e){ toast('Import token non supporté'); }
  };

  if(load('furia_connected',false)){
    ensureProvider().then(async()=>{
      const accs = await provider.listAccounts();
      if(accs[0]){ me=accs[0]; signer=provider.getSigner(); afterConnectUI(); onReady(); }
    }).catch(()=>{});
  }
  if(window.ethereum && window.ethereum.on){
    window.ethereum.on('accountsChanged', ()=>window.location.reload());
    window.ethereum.on('chainChanged',  ()=>window.location.reload());
  }

  /* ========= Contracts ========= */
  async function initContracts(){
    const base = signer ?? provider;
    swap = new ethers.Contract(SWAP_ADDRESS, SWAP_ABI, base);
    vault= new ethers.Contract(VAULT_ADDRESS,VAULT_ABI, base);
    usdc = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, base);
    try{ usdcDecimals = await usdc.decimals(); }catch{}
    try{ price8 = Number(await vault.ethUsd()); }catch{ try{ price8 = Number(await swap.ethUsd()); }catch{ price8=0; } }
    try{ feeBps = Number(await swap.feeBps()); }catch{ feeBps=0; }
    $("#priceBox").textContent = '$'+(price8/1e8).toLocaleString();
    $("#feeBox").textContent   = (feeBps/100).toFixed(2)+'%';
  }

/* ========= Helpers UI ========= */

// --- Helper: simuler puis estimer, en surfacant la raison d'échec ---
async function safeSimThenEstimate(fn, args = [], overrides = {}) {
  try {
    // Simulation (ne consomme pas de gas)
    await fn.callStatic(...args, overrides);
    // Estimation si la simu passe
    const gas = await fn.estimateGas(...args, overrides);
    return { ok: true, gas };
  } catch (e) {
    const reason = e?.reason || e?.error?.message || e?.message || 'Revert / estimation impossible';
    return { ok: false, reason, error: e };
  }
}

  function currentSlippage(){ const v=parseFloat($("#slippage").value || load('cfg_slippage','0.5')); return isFinite(v)&&v>=0?v:0.5; }
  async function updateAllowanceBox(){
    try{
      if(!me){ $("#allowBox").textContent='Allowance USDC → Swap: —'; return; }
      const a = await usdc.allowance(me, SWAP_ADDRESS);
      $("#allowBox").textContent = `Allowance USDC → Swap: ${fmt(Number(a)/10**usdcDecimals)}`;
    }catch{}
  }
  async function refreshBalances(){
    if(!provider) return;
    const p = signer ?? provider;
    const addr = me || (await p.listAccounts())[0];
    if(!addr){ $("#balances").textContent='Solde: —'; return; }
    const ethBal = await provider.getBalance(addr);
    const usdcBal= await usdc.balanceOf(addr);
    $("#balances").textContent = `Solde: ${fmt(ethers.utils.formatEther(ethBal))} ETH · ${fmt(Number(usdcBal)/10**usdcDecimals)} USDC`;
  }

  function updateQuote(){
    const from=$("#swapFrom").value, to=$("#swapTo").value;
    const amt=parseFloat($("#swapAmount").value);
    if(!isFinite(amt) || amt<=0 || !price()){
      $("#youReceive").textContent='—'; $("#minOutBox").textContent='Min. reçu (slippage): —'; return;
    }
    let out=0;
    if(from==='ETH' && to==='USDC'){ out = applyFee(amt*price()); $("#youReceive").textContent = fmt(out,4)+' USDC'; }
    else if(from==='USDC' && to==='ETH'){ out = applyFee(amt/price()); $("#youReceive").textContent = fmt(out,6)+' ETH'; }
    const minOut = out * (1 - currentSlippage()/100);
    $("#minOutBox").textContent = `Min. reçu (slippage ${currentSlippage()}%): ${fmt(minOut)} ${to}`;
  }
  $("#swapAmount").oninput = ()=>{ updateQuote(); updateGasEstimate(); };
  $("#slippage").oninput = updateQuote;
  $("#swapFrom").onchange = ()=>{ if($("#swapFrom").value===$("#swapTo").value){ $("#swapTo").value = $("#swapFrom").value==='ETH'?'USDC':'ETH'; } updateQuote(); };
  $("#swapTo").onchange   = updateQuote;
  $("#btnFlip").onclick   = ()=>{ const a=$("#swapFrom").value; $("#swapFrom").value=$("#swapTo").value; $("#swapTo").value=a; updateQuote(); };
  $$(".pct").forEach(b=>b.onclick=async()=>{
    if(!me){ toast('Connecte ton wallet'); return;}
    const from = $("#swapFrom").value;
    if(from==='ETH'){
      const bal = await provider.getBalance(me);
      const val = Number(ethers.utils.formatEther(bal)) * (Number(b.dataset.p)/100);
      $("#swapAmount").value = (Math.max(0,val-0.0002)).toFixed(6);
    }else{
      const bal = await usdc.balanceOf(me);
      const val = (Number(bal)/10**usdcDecimals) * (Number(b.dataset.p)/100);
      $("#swapAmount").value = val.toFixed(2);
    }
    updateQuote(); updateGasEstimate();
  });
  document.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ const a=document.activeElement; if(a && (a.id==='swapAmount' || a.id==='slippage')) $("#btnSwap").click(); }});

async function updateGasEstimate(){
  try{
    if(!me){ $("#gasBox").textContent='Estimation gas: —'; return; }

    const from = $("#swapFrom").value, to=$("#swapTo").value;
    let amt = parseFloat($("#swapAmount").value);
    if(!isFinite(amt) || amt<=0 || !price()){ $("#gasBox").textContent='Estimation gas: —'; return; }

    const s = swap.connect(signer);

    if(from==='ETH' && to==='USDC'){
      // pré-check liquidité pour éviter une estimation vouée à revert
      const outUsd = applyFee(amt * price());
      const usdcBalSwap = Number((await usdc.balanceOf(SWAP_ADDRESS)).toString())/10**usdcDecimals;
      if(usdcBalSwap < outUsd){
        $("#gasBox").textContent = 'Estimation gas: bloqué (liquidité USDC insuffisante)';
        return;
      }
      const value = ethers.utils.parseEther(String(amt));
      const res = await safeSimThenEstimate(s.swapETHforUSDC, [], { value, from: me });
      $("#gasBox").textContent = res.ok ? ('Estimation gas: ' + res.gas.toString())
                                        : ('Estimation gas: — (' + res.reason + ')');

    } else if(from==='USDC' && to==='ETH'){
      // pré-check allowance
      const usdcIn = ethers.utils.parseUnits(String(amt), usdcDecimals);
      const allowance = await usdc.allowance(me, SWAP_ADDRESS);
      if(allowance.lt(usdcIn)){
        $("#gasBox").textContent = 'Estimation gas: bloqué (allowance USDC insuffisante)';
        return;
      }
      const res = await safeSimThenEstimate(s.swapUSDCforETH, [usdcIn], { from: me });
      $("#gasBox").textContent = res.ok ? ('Estimation gas: ' + res.gas.toString())
                                        : ('Estimation gas: — (' + res.reason + ')');

    } else {
      $("#gasBox").textContent='Estimation gas: —';
    }
  }catch(e){
    $("#gasBox").textContent='Estimation gas: —';
  }
}

  /* ========= TVL / Volumes ========= */
  async function refreshTvl(){
    const tEth  = Number(ethers.utils.formatEther(await vault.totalETH()));
    const tUsdc = Number((await vault.totalUSDC()).toString())/10**usdcDecimals;
    const tvlEthEq = tEth + usdToEth(tUsdc);
    $("#tvlSwap").textContent  = fmt(tvlEthEq)+' ETH';
    $("#tvlPools").textContent = fmt(tvlEthEq)+' ETH';
    // table pools
    $("#poolRows").innerHTML = `
      <tr>
        <td>ETH / USDC</td>
        <td>${APY_POOL}%</td>
        <td>${fmt(tvlEthEq)}</td>
        <td id="volCell">$0</td>
        <td>1 pt / $ / min</td>
        <td>
          <div class="row" style="gap:8px">
            <button class="btn" id="btnOpenAdd">ADD</button>
            <button class="btn secondary" id="btnOpenRemove">REMOVE</button>
          </div>
        </td>
      </tr>`;
    const btn = $("#btnOpenAdd"); if(btn) btn.onclick = ()=>{ $("#addUsd").value=''; updateAddPreview(); $("#dlgAdd").showModal(); };
    const btnR= $("#btnOpenRemove"); if(btnR) btnR.onclick = ()=>{ $("#rmUsd").value=''; updateRemovePreview(); $("#dlgRemove").showModal(); };
  }
  async function getLogsChunked(address, topicsOr, fromBlock, toBlock, step=50000){
    const logs=[]; let s=fromBlock; const t=(toBlock==='latest')?await provider.getBlockNumber():toBlock;
    while(s<=t){ const e=Math.min(s+step,t); try{ const part=await provider.getLogs({ address, fromBlock:s, toBlock:e, topics:[topicsOr] }); logs.push(...part);}catch(e1){ console.error('getLogs',e1);} s=e+1; }
    return logs;
  }
  async function refreshVolumes24h(){
    try{
      const latest = await provider.getBlockNumber();
      const start = Math.max(0, latest - 120000); // ~24h approx
      let volUsd = 0;
      const iS = new ethers.utils.Interface(SWAP_ABI);
      const sLogs = await getLogsChunked(SWAP_ADDRESS, [iS.getEventTopic('SwapETHforUSDC'), iS.getEventTopic('SwapUSDCforETH')], start, 'latest');
      for(const lg of sLogs){
        const ev = iS.parseLog(lg);
        if(ev.name==='SwapETHforUSDC'){ const eth=Number(ethers.utils.formatEther(ev.args.ethIn)); const p8=Number(ev.args.price8)/1e8; volUsd += eth*p8; }
        else { const u=Number(ev.args.usdcIn)/10**usdcDecimals; volUsd += u; }
      }
      const iV = new ethers.utils.Interface(VAULT_ABI);
      const vLogs = await getLogsChunked(VAULT_ADDRESS, [iV.getEventTopic('DepositETH'), iV.getEventTopic('DepositUSDC')], start, 'latest')
        .catch(()=>[]); // si events pas dispo ABI, ignore
      for(const lg of vLogs){
        const ev = iV.parseLog(lg);
        if(ev.name==='DepositETH'){ volUsd += ethToUsd(Number(ethers.utils.formatEther(ev.args.amount))); }
        else if(ev.name==='DepositUSDC'){ volUsd += Number(ev.args.amount)/10**usdcDecimals; }
      }
      $("#volPools").textContent = fmtUsd(volUsd);
      const cell=$("#volCell"); if(cell) cell.textContent=fmtUsd(volUsd);
    }catch(e){ console.error(e); }
  }

  /* ========= Points ========= */
  async function refreshMySwapPoints(){
    try{
      if(!provider || !SWAP_ADDRESS){ $("#mySwapPts").textContent = '0'; return; }
      const who = me || (await (signer ?? provider).listAccounts())[0];
      if(!who){ $("#mySwapPts").textContent = '—'; return; }
      const iS = new ethers.utils.Interface(SWAP_ABI);
      const logs = await getLogsChunked(SWAP_ADDRESS, [iS.getEventTopic('SwapETHforUSDC'), iS.getEventTopic('SwapUSDCforETH')], 0, 'latest');
      let usdTotal = 0;
      for(const lg of logs){
        const ev = iS.parseLog(lg);
        const u  = ev.args.user.toLowerCase();
        if(u !== who.toLowerCase()) continue;
        if(ev.name === "SwapETHforUSDC"){
          const ethIn = Number(ethers.utils.formatEther(ev.args.ethIn));
          const p8    = Number(ev.args.price8)/1e8;
          usdTotal += ethIn * p8;
        }else{
          const usdcIn = Number(ev.args.usdcIn) / 10**usdcDecimals;
          usdTotal += usdcIn;
        }
      }
      const points = usdTotal * 10; // 10 pts / $
      $("#mySwapPts").textContent = Math.floor(points).toLocaleString();
    }catch(e){ console.error(e); }
  }
  async function refreshMyVaultPoints(){
    try{
      const who = me || (await (signer ?? provider).listAccounts())[0];
      if(!who){ $("#myVaultPts").textContent='—'; return; }
      const scaled = await vault.pendingPointsScaled(who);         // live, comme ton code qui marche
      const pts = Number(ethers.utils.formatUnits(scaled || '0', 6));
      $("#myVaultPts").textContent = pts.toLocaleString(undefined,{maximumFractionDigits:2});
    }catch(e){ console.error(e); $("#myVaultPts").textContent='—'; }
  }
  async function loadParticipants(){
    try{
      const iV=new ethers.utils.Interface(VAULT_ABI);
      const logs=await getLogsChunked(VAULT_ADDRESS,[iV.getEventTopic('DepositETH'),iV.getEventTopic('DepositUSDC'),iV.getEventTopic('WithdrawETH'),iV.getEventTopic('WithdrawUSDC')], 0, 'latest').catch(()=>[]);
      const addrs=new Set(); for(const lg of logs){ if(lg.topics[1]) addrs.add('0x'+lg.topics[1].slice(26)); }
      return Array.from(addrs);
    }catch(e){ console.error(e); return []; }
  }
  async function refreshLeaderboard(){
    const addrs = await loadParticipants();
    if(me && !addrs.includes(me)) addrs.unshift(me);
    const rows=[];
    for(const a of addrs){
      try{
        const res = await vault.pointsOf(a); // (uint256,uint8)
        const raw = Array.isArray(res) ? res[0] : (res.points ?? res[0]);
        const dec = Array.isArray(res) ? (res[1] ?? 6) : (res.decimals_ ?? 6);
        const pts = Number(ethers.utils.formatUnits(raw || '0', dec));
        rows.push({a,pts});
      }catch{}
    }
    rows.sort((x,y)=>y.pts-x.pts);
    $("#lbRows").innerHTML = rows.map((r,i)=>`
      <tr>
        <td>${i===0?'':i+1}</td>
        <td><a href="https://base-sepolia.blockscout.com/address/${r.a}" target="_blank">${r.a.slice(0,6)+'…'+r.a.slice(-4)}</a></td>
        <td>${fmt(r.pts,2)}</td>
      </tr>
    `).join('') || `<tr><td colspan="3" class="muted">Aucun participant détecté.</td></tr>`;
    save('lb_cache', rows);
  }
  $("#btnRefreshLB").onclick = refreshLeaderboard;
  $("#btnExportCSV").onclick = ()=>{
    const rows = load('lb_cache',[]);
    const csv = 'rank,address,points\n'+rows.map((r,i)=>`${i+1},${r.a},${r.pts}`).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='leaderboard.csv'; a.click(); URL.revokeObjectURL(url);
  };

  /* ========= Tabs ========= */
  $$(".tab").forEach(t=>t.onclick=()=>{
    $$(".tab").forEach(x=>x.classList.remove('active')); t.classList.add('active');
    ["swap","pools","vaults","leaderboard","settings"].forEach(id=>{
      $("#"+id).style.display = (t.dataset.tab===id)?(id==='swap'?'grid':'block'):'none';
    });
    if(t.dataset.tab==="pools"){ refreshTvl(); refreshMySwapPoints(); refreshVolumes24h(); refreshMyVaultPoints(); }
    if(t.dataset.tab==="leaderboard"){ refreshLeaderboard(); }
  });

  /* ========= Swap ========= */
  $("#btnApproveMax").onclick = async ()=>{
    try{
      if(!me){ await connect(); }
      const max = load('cfg_approve_max','1000000000000');
      const amt = ethers.utils.parseUnits(String(max), usdcDecimals);
      const tx  = await usdc.connect(signer).approve(SWAP_ADDRESS, amt);
      toast("Approve max en cours…");
      await tx.wait(); toast("Approve confirmé "); updateAllowanceBox();
    }catch(e){ console.error(e); toast('Échec approve'); }
  };
  $("#btnSwap").onclick = async ()=>{
  try{
    if(!me){ await connect(); }
    const from = $("#swapFrom").value, to=$("#swapTo").value;
    let amt = parseFloat($("#swapAmount").value);
    if(!isFinite(amt) || amt<=0){ toast("Montant invalide"); return; }

    const s = swap.connect(signer);

    if(from==='ETH' && to==='USDC'){
      // Vérif liquidité côté contrat de swap
      const outUsd = applyFee(amt * price());
      const usdcBalSwap = Number((await usdc.balanceOf(SWAP_ADDRESS)).toString())/10**usdcDecimals;
      if(usdcBalSwap < outUsd){ toast('Pas assez de liquidité USDC dans le contrat de swap.'); return; }

      // Vérif solde ETH (frais inclus)
      const need = ethers.utils.parseEther(String(amt));
      const bal  = await provider.getBalance(me);
      if(bal.lt(need)){ toast('Solde ETH insuffisant'); return; }

      // Simu + estimation → gasLimit avec marge
      const overrides = { value: need, from: me };
      const sim = await safeSimThenEstimate(s.swapETHforUSDC, [], overrides);
      if(!sim.ok){ toast('Swap impossible: '+sim.reason); return; }

      const gasLimit = sim.gas.mul(12).div(10); // +20%
      const tx = await s.swapETHforUSDC({ ...overrides, gasLimit });
      toast("Swap ETH→USDC envoyé…"); await tx.wait(); toast("Swap confirmé ");

    } else if(from==='USDC' && to==='ETH'){
      const usdcIn = ethers.utils.parseUnits(String(amt), usdcDecimals);

      // Approve si nécessaire (avant la simu)
      const allowance = await usdc.allowance(me, SWAP_ADDRESS);
      if(allowance.lt(usdcIn)){
        const txa = await usdc.connect(signer).approve(SWAP_ADDRESS, usdcIn);
        toast("Approve USDC…"); await txa.wait();
      }

      // Simu + estimation → gasLimit avec marge
      const sim = await safeSimThenEstimate(s.swapUSDCforETH, [usdcIn], { from: me });
      if(!sim.ok){ toast('Swap impossible: '+sim.reason); return; }

      const gasLimit = sim.gas.mul(12).div(10); // +20%
      const tx = await s.swapUSDCforETH(usdcIn, { from: me, gasLimit });
      toast("Swap USDC→ETH envoyé…"); await tx.wait(); toast("Swap confirmé ");

    } else {
      toast("Sélection invalide."); return;
    }

    await refreshBalances(); await refreshTvl(); await refreshMySwapPoints(); updateQuote(); await updateAllowanceBox(); await refreshVolumes24h();
  }catch(e){
    console.error(e);
    const msg=(e && (e.data && e.data.message || e.message)) || 'Échec du swap';
    toast(msg);
  }
};

  /* ========= Pools ADD/REMOVE 50/50 ========= */
  $("#btnAddCancel").onclick = ()=>$("#dlgAdd").close();
  function updateAddPreview(){
    const usd = parseFloat($("#addUsd").value);
    if(!isFinite(usd) || usd<=0){ $("#addEthPreview").value=''; $("#addUsdcPreview").value=''; return; }
    const half = usd/2; $("#addEthPreview").value = fmt(usdToEth(half))+' ETH'; $("#addUsdcPreview").value = fmt(half)+' USDC';
  }
  $("#addUsd").oninput = updateAddPreview;
  $("#btnAddConfirm").onclick = async ()=>{
    try{
      if(!me){ await connect(); }
      const usd = parseFloat($("#addUsd").value);
      if(!isFinite(usd) || usd<=0){ toast("Montant invalide"); return; }
      const halfUsd = usd/2;
      const ethAmt  = usdToEth(halfUsd);
      const usdcAmt = halfUsd;
      const vSigner = vault.connect(signer);
      toast('Dépôt ETH en cours…');
      const tx1 = await vSigner.depositETH({ value: ethers.utils.parseEther(String(ethAmt)) });
      await tx1.wait();
      const need = ethers.utils.parseUnits(String(usdcAmt), usdcDecimals);
      const allowance = await usdc.allowance(me, VAULT_ADDRESS);
      if(allowance.lt(need)){ toast('Approve USDC…'); const txa = await usdc.connect(signer).approve(VAULT_ADDRESS, need); await txa.wait(); }
      toast('Dépôt USDC…'); const tx2 = await vSigner.depositUSDC(need); await tx2.wait();
      toast('Dépôt 50/50 réussi '); $("#dlgAdd").close();
      await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du dépôt'); }
  };

  $("#btnRemoveCancel").onclick = ()=>$("#dlgRemove").close();
  function updateRemovePreview(){
    const usd = parseFloat($("#rmUsd").value);
    if(!isFinite(usd) || usd<=0){ $("#rmEthPreview").value=''; $("#rmUsdcPreview").value=''; return; }
    const half = usd/2; $("#rmEthPreview").value = fmt(usdToEth(half))+' ETH'; $("#rmUsdcPreview").value = fmt(half)+' USDC';
  }
  $("#rmUsd").oninput = updateRemovePreview;
  $("#btnRemoveConfirm").onclick = async ()=>{
    try{
      if(!me){ await connect(); }
      const usd = parseFloat($("#rmUsd").value);
      if(!isFinite(usd) || usd<=0){ toast("Montant invalide"); return; }
      const halfUsd = usd/2;
      const ethAmt  = usdToEth(halfUsd);
      const usdcAmt = halfUsd;
      const vSigner = vault.connect(signer);
      toast('Retrait ETH…'); const tx1 = await vSigner.withdrawETH(ethers.utils.parseEther(String(ethAmt))); await tx1.wait();
      toast('Retrait USDC…'); const tx2 = await vSigner.withdrawUSDC(ethers.utils.parseUnits(String(usdcAmt), usdcDecimals)); await tx2.wait();
      toast('Retrait 50/50 effectué '); $("#dlgRemove").close();
      await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du retrait'); }
  };

  /* ========= Vaults actions ========= */
  $("#btnVaultMaxETH").onclick = async ()=>{
    if(!me){ await connect(); }
    const bal = await provider.getBalance(me);
    const val = Math.max(0, Number(ethers.utils.formatEther(bal)) - 0.0002);
    $("#vaultEthAmount").value = val.toFixed(6);
  };
  $("#btnVaultMaxUSDC").onclick = async ()=>{
    if(!me){ await connect(); }
    const bal = await usdc.balanceOf(me);
    $("#vaultUsdcAmount").value = (Number(bal)/10**usdcDecimals).toFixed(2);
  };
  $("#btnVaultDepositETH").onclick = async ()=>{
    if(!me){ await connect(); }
    const v = parseFloat($("#vaultEthAmount").value);
    if(!isFinite(v)||v<=0){ toast('Montant invalide'); return; }
    try{
      const tx = await vault.connect(signer).depositETH({ value: ethers.utils.parseEther(String(v)) });
      await tx.wait(); toast('Déposé '); await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du dépôt'); }
  };
  $("#btnVaultDepositUSDC").onclick = async ()=>{
    if(!me){ await connect(); }
    const v = parseFloat($("#vaultUsdcAmount").value);
    if(!isFinite(v)||v<=0){ toast('Montant invalide'); return; }
    try{
      const amt = ethers.utils.parseUnits(String(v), usdcDecimals);
      const allowance = await usdc.allowance(me, VAULT_ADDRESS);
      if(allowance.lt(amt)){ const txa = await usdc.connect(signer).approve(VAULT_ADDRESS, amt); await txa.wait(); }
      const tx = await vault.connect(signer).depositUSDC(amt);
      await tx.wait(); toast('Déposé '); await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du dépôt'); }
  };
  $("#btnVaultWithdrawETH").onclick = async ()=>{
    if(!me){ await connect(); }
    const v = parseFloat($("#vaultEthWithdraw").value);
    if(!isFinite(v)||v<=0){ toast('Montant invalide'); return; }
    try{
      const tx = await vault.connect(signer).withdrawETH(ethers.utils.parseEther(String(v)));
      await tx.wait(); toast('Retiré '); await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du retrait'); }
  };
  $("#btnVaultWithdrawUSDC").onclick = async ()=>{
    if(!me){ await connect(); }
    const v = parseFloat($("#vaultUsdcWithdraw").value);
    if(!isFinite(v)||v<=0){ toast('Montant invalide'); return; }
    try{
      const tx = await vault.connect(signer).withdrawUSDC(ethers.utils.parseUnits(String(v), usdcDecimals));
      await tx.wait(); toast('Retiré '); await refreshBalances(); await refreshTvl(); await refreshLeaderboard(); await refreshVolumes24h(); await refreshMyVaultPoints();
    }catch(e){ console.error(e); toast('Échec du retrait'); }
  };

  /* ========= Settings ========= */
  $("#cfgSlippage").value = load('cfg_slippage','0.5');
  $("#cfgApproveMax").value = load('cfg_approve_max','1000000000000');
  $("#btnSaveCfg").onclick = ()=>{ save('cfg_slippage', $("#cfgSlippage").value); save('cfg_approve_max', $("#cfgApproveMax").value); toast('Paramètres sauvegardés'); updateQuote(); };

  /* ========= Boot ========= */
  async function onReady(){
    await initContracts();
    $("#vaultEthApy").textContent = APY_VAULT+'%';
    $("#vaultUsdcApy").textContent = APY_VAULT+'%';
    updateQuote();
    await refreshBalances();
    await refreshTvl();
    await refreshLeaderboard();
    await refreshMySwapPoints();
    await refreshMyVaultPoints();
    await updateAllowanceBox();
    await refreshVolumes24h();
  }
  await ensureProvider().catch(()=>{});
  if(provider){ onReady(); }

  /* ========= Tick 10s ========= */
  setInterval(async ()=>{
    try{
      price8 = Number(await vault.ethUsd()); // garde la source de vérité on-chain
      $("#priceBox").textContent = '$'+(price8/1e8).toLocaleString();
      updateQuote();
      await refreshTvl();
      await refreshLeaderboard();
      await refreshMySwapPoints();
      await refreshMyVaultPoints();
      await refreshVolumes24h();
    }catch{}
  }, 10000);
})();
</script>
</body>
</html>
